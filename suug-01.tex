% -*- coding: utf-8 -*-

\chapter{DNS その攻撃手法}
% * (アスタリスク)付きの \chapter* コマンドは原則不可とする

\begin{flushright}
 {\headfont suu-g (@suu\_g)}
\end{flushright}

\section{はじめに}

コンピューティングにおいてネットワーク性を無視できなくなった現代においては、
インターネットはその存在自体が基盤になりつつあります。
いまでは、その上でコンピューティングを行ういわゆるクラウド（笑）コンピューティングが
全盛期で、SaaS, HaaS, IaaS に続いて最近はPaaSも発達してきています。
また、より身近なところでも、我々はDropboxを使ってデータを持ち運び、
Gmailを出先でも見て、TwitterやLine, Skypeで友人らと話し合い、フラッシュメモリがflickrに写真をアップロードし、
家にいるときに電話が鳴ったらインターネットVPNで職場に繋ぎ、と
コンピュータで使用する機能は大抵インターネットを経由するものとなっています。

DNSは、このインターネットの世界で最も広く成功している広域分散DBです\footnote{この本に書くためのこじつけ完了}。
あらゆるサービスを利用する際に、DNSはその裏で粛々と仕事をしています。
ですが、その仕事は、我々が本当に信頼して良いレベルのものなのでしょうか？
ソフトウェアレベルで考えている人は、どの程度DNSに気を使ったらよいのでしょうか？
この記事では、DNS への広く知られた攻撃手法を説明していきます。

なお筆者は趣味のDNS運用者であり趣味のDNS勉強者であるだけなので、
この文章に書かれたことについて責任を持てません。
記述に問題がある部分があれば、教えていただけると幸いです。

\section{DNSと攻撃}

DNS には基本的には三つの登場人物があります。端末（スタブリゾルバ）、
キャッシュサーバ（フルリゾルバ）、それから権威サーバです。
このうち、DNSにおいて「攻撃」の対象となるのは、基本的にはキャッシュ
サーバです\footnote{DNS Amp攻撃とかは別系統なのでここでは取り上げません}。
キャッシュサーバに偽の情報を注入することで、そのキャッシュサーバを
利用しているホスト群を攻撃する手がかりにします。

キャッシュサーバと言っても影響範囲は様々で、ISPのキャッシュサーバであれば
それこそ数万人への影響がありうるでしょうし、あるいは家庭のキャッシュサーバ
への攻撃があれば影響は数人ですが、そこに標的型メールが来れば非常に効果的な
攻撃になり得ます。
DNSへの攻撃は、ソフトウェア利用時に即座に見破ることは困難ですから、攻撃を受けた時の被害も甚大です。

\subsection{正常なシナリオ}
ユーザ吉田くんは、example.jp の IP アドレスを知りたいため、キャッシュサーバ
Alice に DNS Request を送ります。Alice は権威サーバ Bob に問い合わせを送り、
帰ってきた Response をキャッシュします。そして、その Response やキャッシュに
基づいて Alice は吉田くんに Response を返します。これが一連の正常なシナリオです。

\subsection{攻撃シナリオ}
一言で言うと、「本来のパケットが来る前に偽造パケットを送り込めばいい」
というのが DNS における基本的な攻撃手法です。
キャッシュサーバ Alice が権威サーバ Bob に対して問い合わせを送るとき、
Bob が送った Response が帰ってくる前に攻撃者 Charlie が偽造パケットを
Alice に送ることができたなら、攻撃は成立します。

この攻撃は、もし実現ができるのなら他のどんなプロトコルでも同じことが
できるのですが、 DNS ではそれが極端にやりやすくなっています。
その理由を、パケットフォーマットを見ながら追って行きましょう。

\subsection{パケットの偽造}
DNSの脆弱性は、基本的にはそれがUDPの上で動いていることに起因します。

\begin{figure}[hbt]
{\scriptsize
\begin{verbatim}
                                    
                                    0      7 8     15 16    23 24    31  
                                   +--------+--------+--------+--------+ 
                                   |     Source      |   Destination   | 
                                   |      Port       |      Port       | 
                                   +--------+--------+--------+--------+ 
                                   |                 |                 | 
                                   |     Length      |    Checksum     | 
                                   +--------+--------+--------+--------+ 
\end{verbatim}
}
\caption{UDP Header Format}
\label{UDPHeader}
\end{figure}

\begin{figure}[hbt]
{\scriptsize
\begin{verbatim}

                                                             1  1  1  1  1  1
                               0  1  2  3  4  5  6  7  8  9  0  1  2  3  4  5
                             +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                             |                      ID                       |
                             +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                             |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |
                             +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                             |                    QDCOUNT                    |
                             +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                             |                    ANCOUNT                    |
                             +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                             |                    NSCOUNT                    |
                             +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
                             |                    ARCOUNT                    |
                             +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
\end{verbatim}
}
\caption{DNS Header Format}
\label{DNSHeader}
\end{figure}


UDP パケットは RFC768 \footnote{http://tools.ietf.org/html/rfc768}
で定義されているように、ポート番号(16bit)と長さ・チェックサムしかない
極めて簡素なパケットです（図\ref{UDPHeader}）。
またDNSパケットのヘッダフォーマットは RFC 1035 \footnote{http://tools.ietf.org/html/rfc1035} 
にあります。
DNS パケットには、クエリ自体に関する情報以外に 16bit の Query ID が入っています（図\ref{DNSHeader}）。

DNSのパケットを偽造する際には、Destination Port Number 及びDNS Query
ID を偽装しさえすれば、攻撃対象のサーバに受け付けられるパケットになります。
これらは実際のパケットを見れば確実に取得できますが、そうでない場合でも
この32bitの範囲を推定して攻撃することが可能です。
32bit の範囲を推定しての攻撃では一見すると成功率が低そうですが、
攻撃について深掘りされていなかった時代のDNSサーバ実装では、ポート番号や
Query ID のランダム性に問題があるものが多く、攻撃は比較的容易に成立しました。
通常ソースポートとして使用されるのは30000番以上のポートですが、過去の実装
ではそのソースポート番号がシーケンシャルに増加するような実装や、
ランダムの範囲が狭いような実装、さらにはソースポートが53番（！）固定の
実装などがありました。クエリIDも同様に、シーケンシャルに増加する場合は
攻撃が非常に容易になります。

また、空間的には 32 bit なのですが、それが十分広いかというと案外そうでもありません。
いわゆる「お誕生日問題」です。比較的有名な話ですが、
「あるグループ内に誕生日が同じ人がいる確率が50\%以上になるのは23人と、直感に反して少ない」
という小話です。これは 32 bit 空間でも同じことが言えます。
特に、DNSへの攻撃は「一回でも」当たりが出ればそれで攻撃が成立しますから、
この空間の意外な狭さというのは研究者や運用者の目を濁らせます。
ただ、DNSにはキャッシュ保持時間がありますから、一回毒入れに失敗すると
その後キャッシュが切れるまでは同じドメインへの攻撃はできません。
このキャッシュのおかげで、DNSへの攻撃というのは実際には難しいものだと
楽観視されていました。

話は戻りますが、パケット偽装の際は当然IPパケットも偽装します。UDP なので、攻撃対象サーバには一撃だけ
受け付けられれば攻撃成立です。つまり、TCPと違って Source IP Address の偽装がリスクになりません。
権威サーバのメッセージ偽装が成功するのは、このようなUDPの特性があるからこそでもあります。

\subsection{UDPとTCP}
DNSのパケット偽装が攻撃力を持っているのはUDPを使っているせいなのですが、ではTCPを使おうと
言うと、今度はDNS運用者からの猛烈な反対に遭います。
TCPは状態を持ち、意外と限られているリソースを消費してしまうため、
短時間で大量のクエリを捌く必要のあるDNSサーバとしては使用したくないのです。

DNSのルートサーバに求められる性能は10kqps以上はあります。
経験がある方もいらっしゃるでしょうが、TCPにはTIME\_WAIT状態があり、
通信が終了したあとになってもしばらくはそのポート番号を使用すること
ができません。このため、UDPの場合と比較してより長い間、ポート番号を
占拠することになります。
状態を保存する問題は、ファイアーウォールやロードバランサーにも一応
同様のことが起き得ます。
たかだか 16bit しかないポート番号の枯渇は、CPU やメモリの強化では
対応できません。今後コンピュータの性能が上がっていくにつれ、どんどん
ボトルネックとして他の性能を活かせなくなっていくでしょう。

このような性能上の問題があるので、現状では「全てのUDPのDNSパケットを
生まれる前に消し去りたい、全てのDNSパケットを、TCP上に」という祈りは、
因果律に対する反逆です。
とは言うものの、セキュリティを意識したDNSを現実的に実装するためには、
現状ではTCPよりも良い手段はありません。

\subsection{DNSSECとEDNS0}
ポート番号やクエリIDでメッセージの真正性を担保できない、ということが
ここでの問題です。言い方を変えると、真正性を担保できるのであれば、
別にUDPのままでもいいわけです。
そこで出てくるのが DNSSEC + EDNS0 です。
DNSSECは信頼のチェーンを公開鍵を用いて構成していく手法です。
また EDNS0 により DNSSEC の長いメッセージ長にも対応できるようになりました。
\footnote{DNSのパケット長は歴史的経緯により512バイトに制限されており、
DNSSECのような長大なメッセージを伝えるのに不向きでした}
これなら確かにUDPを用いたままでもメッセージの真正性を確認できそうです。
DNSSECは運用管理が難しいと言われていますが、徐々にツールも揃ってきており、
なんとか運用できる形になりつつあるのかなという印象です。

しかし、現状のDNSSECのパケットはUDPの1パケットに収まらない程度に大きく
なりそうだという問題があります。例えば、2012年11月の時点では、 dig +vc jprs.jp rrsig 
とすると確実にTCPでのDNS問い合わせが起こります。
jprs.jp の RRSIG レコードは 1656 バイトあります。これは Ethernet Frame の MTU すら
超えており、1パケットには収まりません。結果、TCPフォールバックが起こります。
DNSSECは元々、DNSのトランスポートセキュリティを、TCPを使わずに担保することが
目的だったのに、結局TCPが必要になってしまう…という矛盾がここにあります。

もっとも、AやAAAAレコードとそのRRSIGレコードのみを持っているようなドメイン
を考えると、まず1200バイトも行かないでしょうし、そういうドメインへの
問い合わせが大多数になるでしょうから、末端のサーバに関してはDNSSECによって
サーバ負荷を減らすことは可能になりそうではあります。


\section{Kashpureff型攻撃}
DNSのプロトコルはRFCに記述されるべきことが書かれていないケースが非常に
多いのですが、1997年、実際にその問題を突いた攻撃が起こり、その問題を露わに
しました。
この攻撃は、発見者の名前を取ってKashpureff型攻撃と呼ばれています。
この攻撃は、簡単に言うと 関係のないサイトの情報をadditional sectionに入れ、
それをキャッシュサーバにキャッシュさせることで実現します。
前述したような、偽のパケットを作る必要がなく、攻撃者が適当なネームサーバを管理
していれば実行できるため、影響は極めて大きいものでした。
また DNS のトランスポートにも関係がなく、TCPであっても関係なく毒が入ります。
ただし、攻撃者のDNSサーバはインターネット上で何らかの権威を持っている必要があるため、
犯人の追跡はしやすいことになります。

\subsection{RFCに書いてないけれど問題あるよねっ}
この動作はRFC違反であっても良さそうですが、この時点のRFCではこれは未定義動作でした。
これを受けてか、 1997年7月発行の RFC2181\footnote{http://tools.ietf.org/html/rfc2181} には、
"Additional information from an authoritative answer" に関する扱いが記載されています。
このRFCの中では、Primary zone file から得られた情報・ゾーン転送から得られた情報・
権限のある回答の Authority セクションから得られた情報、などの信頼性の異なる
情報に対して、キャッシュしたときのデータの優先度をつけています。
ここにいたってようやく、DNS のデータの信頼性について指標ができたと言えます。

とはいえ、優先度は定めても、そのデータを何に使って良いかは依然として書かれていません。
具体的に、キャッシュ優先度を並べてみると、以下のようになっています。

\begin{itemize}
  \item Primary zone file から得られた情報（ただし Glue は除く）
  \item Zone transfer から得られた情報（ただし Glue は除く）
  \item 権限のある回答の Answer セクションの権限ある情報
  \item 権限のある回答の Authority セクションの情報
  \item Primary zone や zone transfer に含まれる Glue
  \item 権限のない回答の Answer セクション、または権限のある回答の Answer セクションの権限のない情報
  \item 権限のない回答の Authority セクションの情報、または（権限のあるなしにかかわらず）Additional セクションの情報
\end{itemize}

ここで注目すべきは下の方で、「権限のない回答のAdditionalセクション」などが、
ゾーンファイルの情報と同列に並べられていることです。
並んでいるということは、そのキャッシュされた情報は、自分が権限を持っている情報と
同じように、ユーザへと提供しても良いのでしょうか？
キャッシュと言っても、サーバへの問い合わせに使用する場合と、それからユーザへ
直接回答する場合とで異なる戦略があるべきなのは明白です。
しかし残念ながら、RFCではこういった点についての回答は避けています。
そして今なおDNSのRFCには、こういった大事なことが幾つも書かれないままです。


\section{Kaminsky型攻撃}
Kashpureff型攻撃はDNSのプロトコル定義の穴を突いたものでしたが、2008年、さらに
DNSの根底を揺るがす攻撃が出現しました。それがKaminsky型攻撃です。
この攻撃を用いると、ものの10分ほどで確実に、BINDへと毒を入れられたと言うことで、
非常に話題になりました。

Kaminsky型攻撃は、大きく分けて三つの問題を組み合わせています。
UDPを使用しているという問題、キャッシュを回避する手法、そして最後に、プロトコル
自体の脆弱性、その三つです。
UDPについてはご存知のとおりなので省略して、残りの２つについて解説します。

\subsection{キャッシュ回避手法}
Kaminsky型攻撃は、基本的には偽回答を用いた攻撃です。
本来DNSのキャッシュにはTTLがあるため、同じドメインへの攻撃は連続してできないという問題があります。
ですがKaminsky型攻撃では、一切の待ち時間なしにあるドメインへの攻撃が可能となります。
待ち時間がないということは、ひたすら繰り返していればいつか確率の壁を越えて
偽造DNSパケットが受け付けられる日が来るということです。
このキャッシュ回避手法は、狭義のカミンスキーアタックとも言われる場合がある$^{［要出典］}$
ほどに特徴的なものなのです。

その攻撃手法とは至って簡単、問い合わせに使う名前をひたすら変えていけばいいのです。
aaa.example.com の次は aab.example.com, aac.example.com, ... と続けて行くことで、
キャッシュを気にせずにひたすら新しいクエリを送りつけることができます。

これほど簡単ならなぜ、これまで誰も気づかなかったのか、というと、このようにサブドメインを
攻撃していったところで、本来ならその上のドメインを攻撃することはできないからです。
ピュアな心で考えてみれば、下のゾーンの情報などいくら受け取ったところで、その親のドメインの
情報を書き換えるはずがないと分かるはずです。
本来であれば、このキャッシュ回避手法が使われたところで、攻撃が成立するはずがないのです。
ない、はずなのですが、そこがKaminsky型攻撃の強いところで、なんと、それが成立するような
DNSパケットの作り方を発見してしまった、これはプロトコルの穴だ、と言うのです。

\subsection{プロトコルの脆弱性}
さて、その恐ろしい手法とはどのようなものなのでしょうか。今はもうオリジナルのPDFは消えて
しまって確認は出来なくなっているのですが、当時のPDFには Additional セクションにある
NS レコードを攻撃者の NS へと書き換えるのだと書かれていました。
ところが、さっきの RFC2181 で紹介したキャッシュ優先順位を考えてみると、Additionalセクション
による情報は優先順位が最低です。すなわち、他の一切の情報が得られていない状態でなければ
キャッシュへ影響を与えることはありません。オリジナルのPDFの手法では攻撃ドメインの子ドメイン
を利用していましたから、親ドメインは確実にキャッシュを持っているわけです。
Kaminsky攻撃ははじめから成立するはずがなかったのです。

ただ、これは少しやり方を変えれば親ドメインの情報をキャッシュさせずに子ドメインを攻撃する
ことは可能です。さらに、 www.example.com NS ns.www.example.com なる情報を読みこませ、その
ns.www.example.com の glue を攻撃者のサーバに向ける攻撃も亜種として考えられます。
さらには、あるドメインの下に存在しないサブドメインを仮想的に作り、そのサブドメインの NS を
additional section から glue として打ち込むような攻撃もあります。

Dan Kaminsky 本人による攻撃は勘違いだった可能性はありますが、本質的な DNS の問題に一歩
近づくことができた点で非常に先進的でした。また元々のやり方でも毒は入ったようで、これに
ついては他の問題と同様に CVE が出て BIND の実装が修正されました。
元々の攻撃方法が成立したことについては、 "Kaminsky Bug" と呼ばれていたりします。

\subsection{Kaminsky型攻撃とは何だったのか}
Kaminsky型攻撃は BIND が優先順位についてバグを持っていたために成立したものでした。
今では基本的にこの攻撃は成功しませんが、工夫した亜種攻撃を用いることで、それなりに
攻撃力のあるものにもなるようです。しかし、この攻撃は基本的には偽装パケットによる
攻撃なので、ポート番号やクエリIDがしっかりとランダム化された最新のサーバを用いる
ことで、今のところは被害に遭う確率を低く抑えることができます。
過剰に怖がる必要はなく、普通にしっかり管理すれば問題にはならないでしょう。


\section{おわりに}
DNSの攻撃手法は様々ありますが、最近ではKaminsky型攻撃はまさにラスボス級の恐ろしさを
もつものでした。その後も幽霊ドメイン問題が発生したり、親子同居問題が判明したりと
DNS界隈はまだまだ賑やかで、そのたびにセキュリティ担当者は必死でアップデートしたり
NSの分散を考えたりする必要がありました。まさに「光ある限り闇もまたある」状態です。

このようにDNSへの問題が次々と発覚している今、ソフトウェア系のサーバ管理者の方にこそ、
DNSへの正しい理解が必要なのではないでしょうか。
DNSサーバを管理する上ではバグフィックスへの対応は欠かせないものです。また、セキュリティ
リスクについても、正しい理解を得ることでより正しい判断を行なっていけるようになるはずです。
この文書が、少しでも皆様のDNSの理解への助けになれば幸甚です。

最後になりましたが、unbound-control-setupはデフォルト1536bitの鍵対を19年間も
有効にしやがるのでくれぐれも気をつけてください。筆者は最近知ってマジ爆笑しました。

