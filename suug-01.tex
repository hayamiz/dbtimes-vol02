% -*- coding: utf-8 -*-

\chapter{DNS}
% * (アスタリスク)付きの \chapter* コマンドは原則不可とする

\begin{flushright}
 {\headfont suu-g (@suu\_g)}
\end{flushright}

\section{はじめに}

% TODO: 書く

SaaS, PaaS, あるいは HaaS, クラウド全盛期の現代ではDNSは最早
基礎技術であり、着目されることはなくなりました。

しかし一方で、DNS というプロトコルがシステムの中で最も弱い
ところになりうるという事実には変わりはありません。

この記事では、DNS の基本的な攻撃手法を、歴史的な順序に沿って
説明していきます。

なお筆者は趣味のDNS運用者であり趣味のDNS勉強者であるだけなので、
この文章に書かれたことについては一切、責任を持てません。

\section{DNSと攻撃}

DNS には基本的には三つの登場人物があります。端末（スタブリゾルバ）、
キャッシュサーバ（フルリゾルバ）、それから権威サーバです。
このうち、DNSにおいて「攻撃」の対象となるのは、基本的にはキャッシュ
サーバです\footnote{DNS Amp攻撃とかは別系統なのでここでは取り上げません}。
キャッシュサーバに偽の情報を注入することで、そのキャッシュサーバを
利用しているホスト群を攻撃する手がかりにします。

\subsection{正常なシナリオ}
ユーザ吉田くんは、example.jp の IP アドレスを知りたいため、キャッシュサーバ
Alice に DNS Request を送ります。Alice は権威サーバ Bob に問い合わせを送り、
帰ってきた Response をキャッシュします。そして、その Response やキャッシュに
基づいて Alice は吉田くんに Response を返します。これが一連の正常なシナリオです。

\subsection{攻撃シナリオ}
一言で言うと、「本来のパケットが来る前に偽造パケットを送り込めばいい」
というのが DNS における攻撃手法です。

キャッシュサーバ Alice が権威サーバ Bob に対して問い合わせを送るとき、
Bob が送った Response が帰ってくる前に攻撃者 Charlie が偽造パケットを
Alice に送ることができたなら、攻撃は成立します。

この攻撃は、もし実現ができるのなら他のどんなプロトコルでも同じことが
できるのですが、 DNS ではそれが極端にやりやすくなっています。
その理由を、パケットフォーマットを見ながら追って行きましょう。

\subsection{パケットの偽造}
DNSの脆弱性は、基本的にはそれがUDPの上で動いていることに起因します。

% TODO: ここにUDPパケットフォーマットの図

UDP パケットは RFC768 \footnote{http://tools.ietf.org/html/rfc768}
で定義されているように、ポート番号(16bit)と長さ・チェックサムしかない
極めて簡素なパケットです。

% TODO: ここにDNSパケットフォーマットの図

またDNSパケットのヘッダフォーマットは RFC 1035 \footnote{何度かアップ
デートもありますが、今回の範囲内では 1035 で十分} にあります。
DNS パケットには、クエリ自体に関する情報以外に 16bit の Query ID が
入っています。

DNSのパケットを偽造する際には、Destination Port Number 及びDNS Query
ID を偽装しさえすれば、攻撃対象のサーバに受け付けられるパケットになります。

IPパケットも普通に偽装します。UDP なので、攻撃対象サーバには一撃だけ
受け付けられれば勝ちです。つまり、TCPと違って Source IP Address の
偽装がリスクになりません。
権威サーバのメッセージ偽装が成功するのは、このようなUDPの特性が
あるからこそでもあります。

\subsection{UDPとTCP}
DNSへの攻撃はもうUDPを使っているせいなのですが、ではTCPを使おうと
言うと、今度はDNS運用者からの猛烈な反対に遭います。

TCPは状態を持ち、意外と限られているリソースを消費してしまうため、
短時間で大量のクエリを捌く必要のあるDNSサーバとしては使用したくない
のです。

DNSのルートサーバに求められる性能は10kqps以上はあります。
経験がある方もいらっしゃるでしょうが、TCPにはTIME\_WAIT状態があり、
通信が終了したあとになってもしばらくはそのポート番号を使用すること
ができません。したがって、UDPの場合と比較してより長い間、ポート番号を
占拠することになります。
状態を保存する問題は、ファイアーウォールやロードバランサーにも一応
同様のことが起き得ます。

たかだか 16bit しかないポート番号の枯渇は、CPU やメモリの強化では
対応できません。今後コンピュータの性能が上がっていくにつれ、どんどん
ボトルネックとして他の性能を活かせなくなっていくでしょう。

このような性能上の問題があるので、現状では「全てのUDPのDNSパケットを
生まれる前に消し去りたい、全てのDNSパケットを、TCP上に」という祈りは、
因果律に対する反逆です。
とは言うものの、セキュリティを意識したDNSを現実的に実装するためには、
現状ではTCPよりも良い手段はありません。

\subsection{DNSSECとEDNS0}
ポート番号やクエリIDでメッセージの真正性を担保できない、ということが
ここでの問題です。言い方を変えると、真正性を担保できるのであれば、
別にUDPのままでもいいわけです。

そこで出てくるのが DNSSEC + EDNS0 です。
DNSSECは信頼のチェーンを公開鍵を用いて構成していく手法です。
また EDNS0 により DNSSEC の長いメッセージ長にも対応できるようになりました。
\footnote{DNSのパケット長は歴史的経緯により512バイトに制限されており、
DNSSECのような長大なメッセージを伝えるのに不向きでした}
これなら確かにUDPを用いたままでもメッセージの真正性を確認できそうです。

DNSSECは運用管理が難しいと言われていますが、徐々にツールも揃ってきており、
なんとか運用できる形になってきたかなという印象です。

しかし、現状のDNSSECのパケットはUDPの1パケットに収まらない程度に大きく
なりそうだという問題があります。例えば、2012年11月の時点では、 dig +vc jprs.jp rrsig 
とすると確実にTCPでのDNS問い合わせが起こります。
jprs.jp の RRSIG レコードは 1656 バイトあり、Ethernet Frame の MTU すら
超えており、1パケットには収まりません。そのため、TCPフォールバックが起こります。

『DNSSECが最終的にTCPを必要とするのであれば、もともとDNSSECがなんのために
導入されたのか謎。TCPならそもそもこの問題が起きないなので、 DNSSECとか
要らないわぁ』という論調があります。 単純にトランスポートの安全性 を保つ
意味合いであればそのとおりかなと思います。
（この点については深堀りは避けます）

もっとも、AやAAAAレコードとそのRRSIGレコードのみを持っているようなドメイン
を考えると、まず1200バイトも行かないでしょうし、そういうドメインへの
問い合わせが大多数になるでしょうから、末端のサーバに関してはDNSSECによって
サーバ負荷を減らすことは可能になりそうではあります。
% TODO: 予想されるパケットサイズとパケットの種類の表

% TODO: 以下適当なので直す
\section{あのー、RFCに書いてないんですけど…}
1997年、Kashpureff型の攻撃あり、乗っ取られたyo。

関係のないサイトの情報をadditional sectionに入れ、それをキャッシュサーバに
キャッシュさせることによって以下略。

これはRFC違反じゃなく、未定義動作。そもそもDNSのRFCにAdditional Sectionが
どう使われる "べき" か書かれていない。全くどうしようもないプロトコルさん
ですね。

今は直っているが、こういう具合に実装に任せた部分がプロトコルに多く存在して
いて、ちょっとプロトコルとしてどうなのよという。

\section{お誕生日問題}
23人いると1/2くらいの確率で誕生日が同じ人がいるらしい、というところ。
つまりたくさん試せば毒が入るかも知れない。けれどキャッシュにはTTLがあって、
毒入れに一度失敗するとしばらく入りません。

一定以上に長いTTLがあれば、それなりに安全だろうと思われていました。


\section{そしてカミンスキーへ…}
カミンスキーは三つの問題の組み合わせ。
UDP問題、キャッシュ回避、プロトコル問題。UDP問題は省略。

お誕生日問題があるといえど、キャッシュのTTLがあるので毒入れは現実的には
それなりに困難だろうと思われていました。それを覆したのがこのカミンスキー
型攻撃、通称カミンスキーアタックです。% TODO: 脚注『カミンスキーアタック言うな』

カミンスキーアタックのキモはキャッシュ回避のための手法。
あるドメインへの攻撃のために、そのドメインのTTLが切れるのを待つ必要が
ないという画期的な攻撃です。

ただ、本来はそれで毒が入るのは実装のミスというか。これもDNSのプロトコル問題
ガッパオ。

という内容を少しまともに書く。
